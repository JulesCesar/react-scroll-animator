(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["library"] = factory(require("react"));
	else
		root["library"] = factory(root["react"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_react__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/animator.tsx":
/*!**************************!*\
  !*** ./src/animator.tsx ***!
  \**************************/
/*! exports provided: AnimationContext, Animator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationContext\", function() { return AnimationContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Animator\", function() { return Animator; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _scrollComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scrollComponent */ \"./src/scrollComponent.tsx\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\n\r\n// A contect for the animator, which pins can use to get data of a section\r\nvar AnimationContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"])({\r\n    getSection: (function () { return undefined; }),\r\n    pageOffset: 0,\r\n});\r\n// The main animator class that will just sequence your variables\r\nvar Animator = /** @class */ (function (_super) {\r\n    __extends(Animator, _super);\r\n    /**\r\n     * Creates an animator component\r\n     * @param props The peroperties of thie element\r\n     */\r\n    function Animator(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        // Stores the biggest vallue that any of the sections have had so far\r\n        _this.largestSectionValues = {};\r\n        // Cache the current section values\r\n        _this.sectionValues = {};\r\n        // The index of the section(s) that is currently changed between 0 and 1\r\n        _this.changingIndex = [0];\r\n        /**\r\n         * Get the peroperty data corresponding to a property name\r\n         * @param name The name of the property\r\n         * @returns The property defined under the given name\r\n         */\r\n        _this.getSection = function (name) {\r\n            return _this.normalizedSections.find(function (prop) { return prop.name == name; });\r\n        };\r\n        // Calculate the normmalized sections\r\n        _this.updateSections(props.sections);\r\n        // Store the initial section values\r\n        _this.sectionValues = _this.getInitialSectionValues();\r\n        _this.largestSectionValues = _this.getInitialSectionValues();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Updates the section variables of the component\r\n     * @param inpSections The sections that were passed\r\n     */\r\n    Animator.prototype.updateSections = function (inpSections) {\r\n        var _this = this;\r\n        var _a = this.normalizeSections(inpSections), sections = _a.sections, sectionsEnd = _a.sectionsEnd, range = _a.range;\r\n        this.normalizedSections = sections;\r\n        this.normalizedSectionsSortedEnd = sectionsEnd;\r\n        this.range = range;\r\n        // Update the offsets\r\n        this.offsets = {};\r\n        this.normalizedSections.forEach(function (section) {\r\n            _this.offsets[section.name + \"Offset\"] = section.offset;\r\n        });\r\n    };\r\n    /**\r\n     * Updates the normalized sections if the scetions changed\r\n     * @param nextProps The new props that will be received\r\n     * @param nextState The new state that will be set\r\n     */\r\n    Animator.prototype.shouldComponentUpdate = function (nextProps, nextState) {\r\n        if (nextProps.sections != this.props.sections) {\r\n            this.updateSections(nextProps.sections);\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Inserts the section into the sections array, keeping the array sorted\r\n     * @param sections The sorted array to insert the section into\r\n     * @param sectionsEnd The sorted array based on the end to insert the section into\r\n     * @param section The section to add into the array\r\n     */\r\n    Animator.prototype.insertSorted = function (sections, sectionsEnd, section) {\r\n        insert: {\r\n            // Insert the section into the correct location to be ordered by offset\r\n            for (var i = 0; i < sections.length; i++) {\r\n                if (section.offset < sections[i].offset) {\r\n                    sections.splice(i, 0, section);\r\n                    break insert;\r\n                }\r\n            }\r\n            sections.push(section);\r\n        }\r\n        insertEnd: {\r\n            // Insert the section into the correct location to be ordered by offset + range\r\n            for (var i = 0; i < sectionsEnd.length; i++) {\r\n                if (section.offset + section.range.delta <\r\n                    sectionsEnd[i].offset + sectionsEnd[i].range.delta) {\r\n                    sectionsEnd.splice(i, 0, section);\r\n                    break insertEnd;\r\n                }\r\n            }\r\n            sectionsEnd.push(section);\r\n        }\r\n    };\r\n    /**\r\n     * Normalizes a single section\r\n     * @param section THe section to be normalized\r\n     * @param offset The offset of the section\r\n     * @returns The normalized section\r\n     */\r\n    Animator.prototype.normalizeSection = function (section, offset) {\r\n        // If the argument is a normal section, get its name and data\r\n        var sectionName = Object.keys(section)[0];\r\n        var data = section[sectionName];\r\n        // Normalize the data, based on range type\r\n        var start = typeof data[0] == \"number\"\r\n            ? data[0]\r\n            : typeof data == \"number\"\r\n                ? data\r\n                : document.body.clientHeight;\r\n        var end = data[1] || 0;\r\n        var delta = start - end;\r\n        // Determine the offset of this section\r\n        if (\"offset\" in section)\r\n            offset += section.offset;\r\n        // Create the section\r\n        return {\r\n            section: {\r\n                name: sectionName,\r\n                index: 0,\r\n                endIndex: 0,\r\n                offset: offset,\r\n                range: {\r\n                    start: start,\r\n                    end: end,\r\n                    delta: delta,\r\n                },\r\n            },\r\n            offset: offset + delta,\r\n        };\r\n    };\r\n    /**\r\n     * Normalizes parallel sections (an array of section arrays) into a flat array of normalized sections\r\n     * @param sections The parallel sections to normalize\r\n     * @param normSections The normalized sections to insert to\r\n     * @param normSectionsEnd The normalized sections sorted on the end to insert to\r\n     * @param offset The initial offset of the sections being considered\r\n     * @returns THe normalized flattened sections\r\n     */\r\n    Animator.prototype.normalizeParallelSections = function (sections, normSections, normSectionsEnd, offset) {\r\n        var _this = this;\r\n        // Go through each of the parallel section lists\r\n        var normSubSections = sections.reduce(function (normSubSections, section) {\r\n            // Compute the normal sections of the sub sections\r\n            var subSections = _this.normalizeSections(section, offset);\r\n            // Compute the range to be the maximum of the ranges\r\n            var range = Math.max(subSections.range, normSubSections.range);\r\n            // Go through each of the sub sections and insert them into the sections\r\n            var sections = normSubSections.sections;\r\n            var sectionsEnd = normSubSections.sectionsEnd;\r\n            subSections.sections.forEach(function (subSection) {\r\n                _this.insertSorted(sections, sectionsEnd, subSection);\r\n            });\r\n            return {\r\n                sections: sections,\r\n                sectionsEnd: sectionsEnd,\r\n                range: range,\r\n            };\r\n        }, { sections: normSections, sectionsEnd: normSectionsEnd, range: 0 });\r\n        // Return the data\r\n        return normSubSections;\r\n    };\r\n    /**\r\n     * Creates a normalized version of the props, considering simple sections and parallel sections\r\n     * @param sections The sections to normalize\r\n     * @param offset The initial offset of the sections being considered\r\n     * @returns The normalized sections\r\n     */\r\n    Animator.prototype.normalizeSections = function (sections, offset) {\r\n        var _this = this;\r\n        if (offset === void 0) { offset = 0; }\r\n        var normSections = sections.reduce(function (normSections, section) {\r\n            // Check whether this is a nested section sequence\r\n            if (section instanceof Array) {\r\n                // Return sections augmented by sub sections\r\n                var normSubSections = _this.normalizeParallelSections(section, normSections.sections, normSections.sectionsEnd, normSections.range);\r\n                // Augment the current data and return it\r\n                return normSubSections;\r\n            }\r\n            else {\r\n                var normSection = _this.normalizeSection(section, normSections.range);\r\n                // Augment the sections list with the new section\r\n                _this.insertSorted(normSections.sections, normSections.sectionsEnd, normSection.section);\r\n                // Return the new data\r\n                return {\r\n                    sections: normSections.sections,\r\n                    sectionsEnd: normSections.sectionsEnd,\r\n                    range: normSection.offset,\r\n                };\r\n            }\r\n        }, { sections: [], sectionsEnd: [], range: offset });\r\n        // Update the indices of the sections\r\n        normSections.sections.forEach(function (section, index) {\r\n            section.index = index;\r\n        });\r\n        normSections.sectionsEnd.forEach(function (section, index) {\r\n            section.endIndex = index;\r\n        });\r\n        return normSections;\r\n    };\r\n    /**\r\n     * Retyrives the section values which are all initialized to 0\r\n     * @returns The sections with value 0\r\n     */\r\n    Animator.prototype.getInitialSectionValues = function () {\r\n        var sections = {};\r\n        this.normalizedSections.forEach(function (section) {\r\n            sections[section.name] = 0;\r\n        });\r\n        return sections;\r\n    };\r\n    /**\r\n     * Retrieves the actual section values given some pprogress\r\n     * @param progress The progress between 0 and the range\r\n     * @returns The sections with their values\r\n     */\r\n    Animator.prototype.updateSectionValues = function (progress) {\r\n        // Compute the values for each of the sections\r\n        for (var i = 0; i < this.changingIndex.length; i++) {\r\n            var index = this.changingIndex[i];\r\n            var section = this.normalizedSections[index];\r\n            var sd = progress - section.offset;\r\n            var delta = section.range.delta;\r\n            var value = Math.min(1, Math.max(0, sd) / delta);\r\n            // Update the value\r\n            this.sectionValues[section.name] = value;\r\n            // Store the maximum in max values\r\n            if (value > this.largestSectionValues[section.name])\r\n                this.largestSectionValues[section.name] = value;\r\n            // Check if the previous animation should start\r\n            var sec = void 0;\r\n            var endIndex = section.endIndex;\r\n            if ((sec = this.normalizedSectionsSortedEnd[endIndex - 1]) &&\r\n                sec.offset + sec.range.delta > progress &&\r\n                this.changingIndex.indexOf(sec.index) == -1)\r\n                this.changingIndex.push(sec.index);\r\n            // Check if the next animation should start\r\n            if ((sec = this.normalizedSections[index + 1]) &&\r\n                sec.offset < progress &&\r\n                this.changingIndex.indexOf(index + 1) == -1)\r\n                this.changingIndex.push(index + 1);\r\n            // If the value hit the minimum, remove it if there are any other animations going\r\n            if (sd < 0 && this.changingIndex.length > 1)\r\n                this.changingIndex.splice(i--, 1);\r\n            // If the value hit the maximum, remove it if there are any other animations going\r\n            if (sd > delta && this.changingIndex.length > 1)\r\n                this.changingIndex.splice(i--, 1);\r\n        }\r\n        // Return the sections\r\n        return this.sectionValues;\r\n    };\r\n    /**\r\n     * Renders the animations content\r\n     * @param progress The progress (between 0 and total range)\r\n     * @returns The rendered jsx element\r\n     */\r\n    Animator.prototype.renderContent = function (progress) {\r\n        var sections = this.updateSectionValues(progress);\r\n        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(AnimationContext.Provider, { value: { getSection: this.getSection, pageOffset: this.pageOffset } },\r\n            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { style: {\r\n                    height: this.range + document.body.clientHeight,\r\n                    width: \"100%\",\r\n                    display: \"inline-block\",\r\n                } }, this.props.children(sections, this.largestSectionValues, this.offsets, progress / this.range))));\r\n    };\r\n    /**\r\n     * Renders the entirety of the animation contents\r\n     */\r\n    Animator.prototype.render = function () {\r\n        var _this = this;\r\n        if (this.props.progress == undefined) {\r\n            // Render the content with the progress based on the scroll position\r\n            return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_scrollComponent__WEBPACK_IMPORTED_MODULE_1__[\"ScrollComponent\"], { elementScroll: this.props.elementScroll }, function (progress, offset) {\r\n                _this.pageOffset = offset;\r\n                return _this.renderContent(progress);\r\n            }));\r\n        }\r\n        else {\r\n            // Render the the content based on progress pased as a prop\r\n            return this.renderContent(this.props.progress * this.range || 0);\r\n        }\r\n    };\r\n    return Animator;\r\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]));\r\n\r\n\n\n//# sourceURL=webpack://library/./src/animator.tsx?");

/***/ }),

/***/ "./src/easing.tsx":
/*!************************!*\
  !*** ./src/easing.tsx ***!
  \************************/
/*! exports provided: EasingFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EasingFunctions\", function() { return EasingFunctions; });\n/**\r\n * Src: https://gist.github.com/gre/1650294,\r\n *  https://gist.github.com/gre/1650294#gistcomment-1892122,\r\n *  https://gist.github.com/gre/1650294#gistcomment-1924831\r\n * Easing Functions - inspired from http://gizma.com/easing/\r\n * only considering the t value for the range [0, 1] => [0, 1]\r\n */\r\nvar EasingFunctions = {\r\n    // no easing, no acceleration\r\n    linear: function (t) {\r\n        return t;\r\n    },\r\n    // accelerating from zero velocity\r\n    easeInQuad: function (t) {\r\n        return t * t;\r\n    },\r\n    // decelerating to zero velocity\r\n    easeOutQuad: function (t) {\r\n        return t * (2 - t);\r\n    },\r\n    // acceleration until halfway, then deceleration\r\n    easeInOutQuad: function (t) {\r\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n    },\r\n    // accelerating from zero velocity\r\n    easeInCubic: function (t) {\r\n        return t * t * t;\r\n    },\r\n    // decelerating to zero velocity\r\n    easeOutCubic: function (t) {\r\n        return --t * t * t + 1;\r\n    },\r\n    // acceleration until halfway, then deceleration\r\n    easeInOutCubic: function (t) {\r\n        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n    },\r\n    // accelerating from zero velocity\r\n    easeInQuart: function (t) {\r\n        return t * t * t * t;\r\n    },\r\n    // decelerating to zero velocity\r\n    easeOutQuart: function (t) {\r\n        return 1 - --t * t * t * t;\r\n    },\r\n    // acceleration until halfway, then deceleration\r\n    easeInOutQuart: function (t) {\r\n        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\r\n    },\r\n    // accelerating from zero velocity\r\n    easeInQuint: function (t) {\r\n        return t * t * t * t * t;\r\n    },\r\n    // decelerating to zero velocity\r\n    easeOutQuint: function (t) {\r\n        return 1 + --t * t * t * t * t;\r\n    },\r\n    // acceleration until halfway, then deceleration\r\n    easeInOutQuint: function (t) {\r\n        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\r\n    },\r\n    // elastic bounce effect at the beginning\r\n    easeInElastic: function (t) {\r\n        return t == 0 ? 0 : (0.04 - 0.04 / t) * Math.sin(25 * t) + 1;\r\n    },\r\n    // elastic bounce effect at the end\r\n    easeOutElastic: function (t) {\r\n        return t == 1 ? 1 : ((0.04 * t) / --t) * Math.sin(25 * t);\r\n    },\r\n    // elastic bounce effect at the beginning and end\r\n    easeInOutElastic: function (t) {\r\n        return t == 0\r\n            ? 0\r\n            : t == 1\r\n                ? 1\r\n                : (t -= 0.5) < 0\r\n                    ? (0.02 + 0.01 / t) * Math.sin(50 * t)\r\n                    : (0.02 - 0.01 / t) * Math.sin(50 * t) + 1;\r\n    },\r\n    easeInSin: function (t) {\r\n        return 1 + Math.sin((Math.PI / 2) * t - Math.PI / 2);\r\n    },\r\n    easeOutSin: function (t) {\r\n        return Math.sin((Math.PI / 2) * t);\r\n    },\r\n    easeInOutSin: function (t) {\r\n        return (1 + Math.sin(Math.PI * t - Math.PI / 2)) / 2;\r\n    },\r\n};\r\n\n\n//# sourceURL=webpack://library/./src/easing.tsx?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: AnimationContext, Animator, latest, map, createRef, RefCreator, Pin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _animator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animator */ \"./src/animator.tsx\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AnimationContext\", function() { return _animator__WEBPACK_IMPORTED_MODULE_0__[\"AnimationContext\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Animator\", function() { return _animator__WEBPACK_IMPORTED_MODULE_0__[\"Animator\"]; });\n\n/* harmony import */ var _latest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./latest */ \"./src/latest.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"latest\", function() { return _latest__WEBPACK_IMPORTED_MODULE_1__[\"latest\"]; });\n\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ \"./src/map.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return _map__WEBPACK_IMPORTED_MODULE_2__[\"map\"]; });\n\n/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ref */ \"./src/ref.tsx\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return _ref__WEBPACK_IMPORTED_MODULE_3__[\"createRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RefCreator\", function() { return _ref__WEBPACK_IMPORTED_MODULE_3__[\"RefCreator\"]; });\n\n/* harmony import */ var _pin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pin */ \"./src/pin.tsx\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Pin\", function() { return _pin__WEBPACK_IMPORTED_MODULE_4__[\"Pin\"]; });\n\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://library/./src/index.ts?");

/***/ }),

/***/ "./src/latest.ts":
/*!***********************!*\
  !*** ./src/latest.ts ***!
  \***********************/
/*! exports provided: latest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"latest\", function() { return latest; });\n/**\r\n * Picks the last value coming from a fraction that is not 1 yet\r\n * @param sections The progress values\r\n * @param values The possibly mapped progress values\r\n * @returns The latest value\r\n */\r\nfunction latest(sections, values) {\r\n    var index = sections.reduce(function (v, section) { return v + (section == 1 ? 1 : 0); }, 0);\r\n    if (index == sections.length)\r\n        index--;\r\n    // return the value\r\n    return values[index];\r\n}\r\n\n\n//# sourceURL=webpack://library/./src/latest.ts?");

/***/ }),

/***/ "./src/map.ts":
/*!********************!*\
  !*** ./src/map.ts ***!
  \********************/
/*! exports provided: map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony import */ var _easing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./easing */ \"./src/easing.tsx\");\n\r\nfunction map(per, start, end, options) {\r\n    // Normalize the arguments\r\n    if (typeof end != \"number\") {\r\n        options = end;\r\n        end = start;\r\n        start = 0;\r\n    }\r\n    if (!options)\r\n        options = {};\r\n    // Apply easing if specified\r\n    if (options.easing)\r\n        per = _easing__WEBPACK_IMPORTED_MODULE_0__[\"EasingFunctions\"][options.easing](per);\r\n    // Calculate the value\r\n    var delta = end - start;\r\n    var val = per * delta + start;\r\n    // Apply rounding if specified\r\n    if (options.digits !== undefined) {\r\n        var n = Math.pow(10, options.digits);\r\n        val = Math.round(val * n) / n;\r\n    }\r\n    // return the value\r\n    return val;\r\n}\r\n\n\n//# sourceURL=webpack://library/./src/map.ts?");

/***/ }),

/***/ "./src/pin.tsx":
/*!*********************!*\
  !*** ./src/pin.tsx ***!
  \*********************/
/*! exports provided: Pin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pin\", function() { return Pin; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _animator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./animator */ \"./src/animator.tsx\");\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\n\r\n\r\n// A element to pin data onto the page at certain sectins, or move the data at the specified sections\r\nvar Pin = function (_a) {\r\n    var sections = _a.sections, children = _a.children, rest = __rest(_a, [\"sections\", \"children\"]);\r\n    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_animator__WEBPACK_IMPORTED_MODULE_1__[\"AnimationContext\"].Consumer, null, function (c) {\r\n        // Retrieve the last started prop, or if there is no such prop, the first unstarted\r\n        var data = Object.keys(sections).reduce(function (best, propName) {\r\n            var section = c.getSection(propName);\r\n            var per = sections[propName];\r\n            if (best.per != 0 && per != 0\r\n                ? section.index > best.section.index\r\n                : section.index < best.section.index) {\r\n                return {\r\n                    section: section,\r\n                    per: per,\r\n                };\r\n            }\r\n            return best;\r\n        }, { section: { index: Infinity }, per: 0 });\r\n        // Extract the data\r\n        var section = data.section;\r\n        var per = data.per;\r\n        // Determine the possible locations\r\n        var scroll = section.range.start + section.offset;\r\n        var start = section.range.start + c.pageOffset;\r\n        var end = section.range.end + c.pageOffset;\r\n        // Apply styling for location based on percentage\r\n        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", __assign({}, rest, { style: per < 1 && per > 0\r\n                ? __assign({ position: \"absolute\", top: scroll }, rest.style) : __assign({ position: \"fixed\", top: per == 0 ? start : end }, rest.style) }), children));\r\n    }));\r\n};\r\n\n\n//# sourceURL=webpack://library/./src/pin.tsx?");

/***/ }),

/***/ "./src/ref.tsx":
/*!*********************!*\
  !*** ./src/ref.tsx ***!
  \*********************/
/*! exports provided: createRef, RefCreator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return createRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RefCreator\", function() { return RefCreator; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\n\r\n// Updates the reference's data\r\nvar updateData = function (ref, element) {\r\n    ref.element = element;\r\n    var rect = element.getBoundingClientRect();\r\n    // Assign the useful properties to the Reference, and rerender the elements\r\n    ref.x = rect.left;\r\n    ref.y = rect.top;\r\n    ref.width = rect.width;\r\n    ref.height = rect.height;\r\n    ref.shape = { width: ref.width, height: ref.height };\r\n};\r\n// Function for creating a reference that calls update when it's data is changed\r\nvar createRef = function (refresh) {\r\n    var self = (function (_a) {\r\n        var children = _a.children, rest = __rest(_a, [\"children\"]);\r\n        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", __assign({}, rest, { style: __assign({ display: \"inline-block\" }, rest.style), ref: function (element) {\r\n                if (!self.element) {\r\n                    updateData(self, element);\r\n                    self.refresh();\r\n                }\r\n            } }), children instanceof Function ? children(refresh) : children));\r\n    });\r\n    self.x = 0;\r\n    self.y = 0;\r\n    self.width = 0;\r\n    self.height = 0;\r\n    self.shape = { width: 0, height: 0 };\r\n    self.update = function () { return self.element && updateData(self, self.element); };\r\n    self.refresh = refresh;\r\n    return self;\r\n};\r\n// Element for maintaing a state with references\r\nvar RefCreator = /** @class */ (function (_super) {\r\n    __extends(RefCreator, _super);\r\n    function RefCreator(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        // Create the references\r\n        var refs = [];\r\n        // Specify the refresh method that should be called when ref data changes\r\n        var refresh = function () { return _this.setState({ refs: refs.map(function (ref) { return ref; }) }); };\r\n        // Create the actual refs\r\n        for (var i = 0; i < (props.count || 1); i++) {\r\n            refs.push(createRef(refresh));\r\n        }\r\n        _this.state = { refs: refs };\r\n        return _this;\r\n    }\r\n    RefCreator.prototype.render = function () {\r\n        var children = this.props.children;\r\n        var refs = this.state.refs;\r\n        // Update the sizes on a redraw\r\n        refs.forEach(function (Ref) {\r\n            Ref.update();\r\n        });\r\n        // Provide refs to child elements\r\n        return children(refs);\r\n    };\r\n    return RefCreator;\r\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]));\r\n\r\n\n\n//# sourceURL=webpack://library/./src/ref.tsx?");

/***/ }),

/***/ "./src/scrollComponent.tsx":
/*!*********************************!*\
  !*** ./src/scrollComponent.tsx ***!
  \*********************************/
/*! exports provided: ScrollComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollComponent\", function() { return ScrollComponent; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\n\r\n/**\r\n * A class that sends offset events when the user scrolls\r\n */\r\nvar ScrollComponent = /** @class */ (function (_super) {\r\n    __extends(ScrollComponent, _super);\r\n    function ScrollComponent() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        // Set the initial state\r\n        _this.state = { offset: 0, scroll: 0 };\r\n        /**\r\n         * Update the offset whenever a scroll occurs\r\n         */\r\n        _this.handleScroll = function (event) {\r\n            _this.setState(function () { return ({\r\n                scroll: event.srcElement.body\r\n                    ? event.srcElement.body.scrollTop\r\n                    : event.srcElement.scrollTop,\r\n            }); });\r\n        };\r\n        return _this;\r\n    }\r\n    /**\r\n     * Adds the scroll listener to the element\r\n     * @param element The element to add the listener to\r\n     */\r\n    ScrollComponent.prototype.addScrollListener = function (element) {\r\n        if (element && element.onscroll != this.handleScroll) {\r\n            element.onscroll = this.handleScroll;\r\n            // Set the initial state\r\n            this.setState({\r\n                offset: element.getBoundingClientRect().top,\r\n                scroll: element.scrollTop,\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Add a scroll listener to the body if not using element scroll\r\n     */\r\n    ScrollComponent.prototype.componentWillMount = function () {\r\n        if (!this.props.elementScroll)\r\n            document.addEventListener(\"scroll\", this.handleScroll, { passive: false });\r\n    };\r\n    /**\r\n     * Remove a scroll listener to the body if not using element scroll\r\n     */\r\n    ScrollComponent.prototype.componentWillUnmount = function () {\r\n        if (!this.props.elementScroll)\r\n            document.removeEventListener(\"scroll\", this.handleScroll);\r\n    };\r\n    /**\r\n     * Renders the chiildren with the scroll callback\r\n     */\r\n    ScrollComponent.prototype.render = function () {\r\n        var _this = this;\r\n        var _a = this.props, children = _a.children, elementScroll = _a.elementScroll, rest = __rest(_a, [\"children\", \"elementScroll\"]);\r\n        // If element scroll is set to true, define a custom element for the scrolling\r\n        if (elementScroll) {\r\n            return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", __assign({}, rest, { style: { height: \"100%\", overflow: \"auto\", position: \"relative\" }, ref: function (element) { return _this.addScrollListener(element); } }), children(this.state.scroll, this.state.offset)));\r\n        }\r\n        else {\r\n            // Otherwise use the body element\r\n            return children(this.state.scroll, this.state.offset);\r\n        }\r\n    };\r\n    return ScrollComponent;\r\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]));\r\n\r\n\n\n//# sourceURL=webpack://library/./src/scrollComponent.tsx?");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n\n//# sourceURL=webpack://library/external_%22react%22?");

/***/ })

/******/ });
});